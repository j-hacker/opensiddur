#!/usr/bin/env python
# Extract the outline (table of contents) from the PDF
# and generate an XSL template.
# For the 1917 JPS PDF extraction project for the Open Siddur Project.
# Copyright 2011-14 Marc Stober and licensed under the terms of the LGPL

# This script now does two things:
# 1. Uses PDFMiner to look at the outline in the PDF and generate a Makefile
#	that separately extracts each book based on its location in the PDF.
# 2. Reads in outline.xsl2.template and writes out outline.xsl2.
#	This is done for each book file.

# Usage (from source/1917JPS directory with symlink to code):
#	code/outline.py 
#		Extract TOC from PDF and generate XSL.
#	code/outline.py -r
#		Extract TOC from PDF and output it (raw).
#	code/outline.py -m
#		Extract TOC from PDF and generate Makefile with target for each book.
#	code/outline.py 853-933
#		Extract TOC from PDF and generate XSL for specific pages.

import os.path
import pprint
import sys
from datetime import datetime
from pdfminer.pdfparser import PDFParser, PDFDocument

def get_toc(extra=False):
	fp = open('Tanakh-JPS1917.pdf', 'rb')
	parser = PDFParser(fp)
	doc = PDFDocument()
	parser.set_document(doc)
	doc.set_parser(parser)
	#doc.initialize(password)

	# Get the page numbers for the page object ID's.
	p = 0
	page_numbers = {}
	for page in doc.get_pages():
		p += 1
		page_numbers[page.pageid] = p
	number_of_pages = len(page_numbers)

	# now what we really want is just the TOC for what was passed in

	# Get the outlines of the document.
	outlines = doc.get_outlines()
	toc = []
	location = [''] * 3
	for (level,title,dest,a,se) in outlines:
		title = title.replace(chr(10), '').replace(chr(13), '').strip()
		# skip the individual chapter number nodes
		if level < 4 and not title.isdigit():
			location[level - 1] = title 
			# Get the destination page number from the action.
			# Thanks to https://groups.google.com/d/topic/pdfminer-users/KwMJHZTCKbE/discussion
			pageid = a.resolve()['D'][0].objid
			entry = location[:level]
			entry.append(page_numbers[pageid])
			toc.append(entry)

	if len(sys.argv) == 1:
		if extra:
			toc.append([number_of_pages])
	else:
		# If a specific list of pages from the original PDF were specified,
		# create a custom TOC.
		selectedPages = sys.argv[1]
		from_page, to_page = [int(pnum) for pnum in selectedPages.split('-')]
		toc = [entry for entry in toc 
					 if entry[-1] >= from_page and entry[-1] <= to_page]
	return toc

def generate_xsl(toc):

	template_file = open(os.path.splitext(__file__)[0] + '.xsl2.template')
	template = template_file.readlines()
	template_file.close()

	for line in template:
		print line.strip()
		if 'GENERATE CODE HERE' in line:
			generate_xsl_sections(toc)
	
	return

def generate_xsl_sections(toc):

	previous_entry = []
	previous_level = -1
	for n, entry in enumerate(toc):
		for level, title in enumerate(entry[:-1]):
			if level >= len(previous_entry):
				same = False
			else:
				same = (title == previous_entry[level])
			if not same:
				close_previous_elements(level, previous_level)

				indent = level * '  '
				if level == 0:
					element_name = 'section'
				elif level == 1 and entry[1] == 'THE TWELVE':
					element_name = 'subsection'
				elif level == 1:
					element_name = 'book'
				elif level == 2 and entry [1] == 'PSALMS':
					element_name = 'subsection'
				elif level == 2:
					element_name = 'book'
				else:
					raise Exception() # not expecting this

				print '%s<xsl:element name="%s">' % (indent, element_name)
				print '%s  <xsl:attribute name="id">%s</xsl:attribute>' % (
					indent, title)

				if level == len(entry) - 2: # leaf node
					if n + 1 < len(toc):
						next_entry = toc[n + 1]
						xpath = 'page[@id >= %s and @id &lt; %s]' % (
							entry[-1], next_entry[-1])
					else: # last section
						xpath = 'page[@id >= %s]' % (entry[-1])
					print '%s  <xsl:apply-templates select="%s"/>' % (
						indent, xpath)

				previous_level = level

		previous_entry = entry

	close_previous_elements(0, previous_level)

	return

def close_previous_elements(level, previous_level):
	levels_to_close = previous_level - level + 1
	if levels_to_close > 0:
		for i in reversed(range(level, previous_level + 1)):
			print (i * '  ') + '</xsl:element>'

	return

def generate_makefile(toc):
	
	print('# Generated by {0} on {1}'.format(
			os.path.split(sys.argv[0])[1], datetime.now()))
	print('')

	write('books:')
	for n, entry in enumerate(toc[:-1]):
		book = entry[-2]
		book_path = get_book_path(book)
		write(' \\\n\t\t{0}'.format(book_path))
	write('\n')
		
	print('')

	for n, entry in enumerate(toc[:-1]):
		# TODO use get_book_path, but PSALMS kludge. Better, avoid doing it in both loops.
		book = entry[-2].replace(' ', '_')
		next_page = toc[n + 1][-1]

		# for Psalms, want one file not "sub-books"
		if entry[1] == 'PSALMS':
			if book != 'PSALMS': continue # "sub-book"
			next_page = 1065 # KLUDGE / MAGIC NUMBER

		last_page = next_page - 1
		pages = '-'.join([str(p) for p in (entry[-1], last_page)])
		print '{0}:'.format(get_book_path(book))
		print('\tmake book book=%s pages=%s' % 
			(book, pages))
		print('')

	return

# Shortcut to sys.stdout.write, a.k.a. print without newline
def write(s):
	sys.stdout.write(s)

def get_book_path(book):
	# make doesn't play nice with spaces.
	# They are put back later to match sefaria-data.
	book = book.replace(' ', '_')
	return 'books/{0}.html'.format(book)

MAKE_OPTION = '-m'

if __name__ == '__main__':

	opts = [arg for arg in sys.argv if arg[0] == '-']
	for opt in opts: sys.argv.remove(opt)

	# TODO: Only call this once and save it, not for each file.
	toc = get_toc(MAKE_OPTION in opts)

	if '-r' in opts:
		pprint.pprint(toc) # debugging

	if MAKE_OPTION in opts:
		# THE TWELVE are all one file.
		# TODO: Still need psalms special case above with this?
		toc = [entry for entry in toc if len(entry) < 4]
		generate_makefile(toc)
	if not len(opts):
		generate_xsl(toc)
