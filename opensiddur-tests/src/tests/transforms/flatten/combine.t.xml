<?xml version="1.0" encoding="utf-8"?>
<TestSuite
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:tei="http://www.tei-c.org/ns/1.0"
  xmlns:j="http://jewishliturgy.org/ns/jlptei/1.0"
  xmlns:jf="http://jewishliturgy.org/ns/jlptei/flat/1.0"
  >
  <suiteName>Combine transform</suiteName>
  <description>
    <p>Tests of combine transform</p>
    <author>Efraim Feinstein</author>
    <copyright>Copyright 2013-2014 Efraim Feinstein
    Licensed under the GNU Lesser General Public License, version 3 or later</copyright>
  </description>
  <namespace prefix="tei">http://www.tei-c.org/ns/1.0</namespace>
  <namespace prefix="j">http://jewishliturgy.org/ns/jlptei/1.0</namespace>
  <namespace prefix="jf">http://jewishliturgy.org/ns/jlptei/flat/1.0</namespace>
  <imports>
    import module namespace format="http://jewishliturgy.org/modules/format"
      at "xmldb:exist:///db/apps/opensiddur-server/modules/format.xqm";
    import module namespace mirror="http://jewishliturgy.org/modules/mirror"
      at "xmldb:exist:///db/apps/opensiddur-server/modules/mirror.xqm";
    import module namespace combine="http://jewishliturgy.org/transform/combine"
      at "xmldb:exist:///db/apps/opensiddur-server/transforms/combine.xqm";
    import module namespace ridx="http://jewishliturgy.org/modules/refindex"
      at "xmldb:exist:///db/apps/opensiddur-server/modules/refindex.xqm";
  </imports>
  <asUser>testuser</asUser>
  <password>testuser</password>
  <functions><![CDATA[
    declare function local:setup($file as xs:string) {
        local:setup($file, "tests")
    };

    declare function local:setup($file as xs:string, $collection as xs:string) {
      xmldb:copy(
        "/db/apps/opensiddur-tests/tests/transforms/flatten", 
        "/db/data/" || $collection, 
        $file),
      let $doc := doc("/db/data/" || $collection || "/" || $file)
      return ( 
        ridx:reindex($doc),
        format:unflatten-dependencies($doc, map {})
      )
    };

    declare function local:tearDown($file as xs:string) {
      local:tearDown($file, "tests")
    };
    
    declare function local:tearDown($file as xs:string, $collection as xs:string) {
      format:clear-caches("/db/data/" || $collection || "/" || $file),
      try {
        xmldb:remove("/db/data/" || $collection, $file)
      }
      catch * {
        ()
      },
      ridx:remove("/db/data/" || $collection,  $file)
    };
  ]]></functions>
  <TestSet>
    <testName>No pointers</testName>
    <setup><code><![CDATA[
    local:setup("combine1.xml")
    ]]></code></setup>
    <tearDown><code><![CDATA[
    local:tearDown("combine1.xml")
    ]]></code></tearDown>
    <test>
      <task>acts as an identity transform</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine1.xml"),
          map {})
      ]]></code>
      <xpath desc="has @jf:document on root element">matches(./tei:TEI/@jf:document,"^(/exist/restxq)?/api/data/tests/combine1$")</xpath>
      <xpath 
        desc="acts as an identity transform for unflattened text" 
        >exists(./tei:TEI/tei:text/jf:combined[@jf:id="stream"]/tei:seg[@jf:id="seg1"][ends-with(@jf:stream,"#stream")])
      </xpath>
    </test>        
  </TestSet>
  <TestSet>
    <testName>Local pointer</testName>
    <setup><code><![CDATA[
    local:setup("combine2.xml")
    ]]></code></setup>
    <tearDown><code><![CDATA[
    local:tearDown("combine2.xml")
    ]]></code></tearDown>
    <test>
      <task>one segment</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine2.xml"),
          map {})
      ]]></code>
      <xpath desc="has @jf:document on root element">matches(./tei:TEI/@jf:document,"^(/exist/restxq)?/api/data/tests/combine2$")</xpath>
      <xpath 
        desc="incorporate destination in-place" 
        >exists(./tei:TEI/tei:text/jf:combined[@jf:id="stream"]/jf:ptr[@jf:id="ptr1"][ends-with(@jf:stream,"#stream")]/tei:seg[@jf:id="seg1"])
      </xpath>
      <xpath desc="no @jf:document attribute on jf:ptr">
        empty(./tei:TEI/tei:text/jf:combined[@jf:id="stream"]/jf:ptr[@jf:id="ptr1"][ends-with(@jf:stream,"#stream")]/@jf:document)
      </xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>External pointer</testName>
    <setup><code><![CDATA[
    local:setup("combine1.xml"),
    local:setup("combine3.xml")
    ]]></code></setup>
    <tearDown><code><![CDATA[
    local:tearDown("combine3.xml"),
    local:tearDown("combine1.xml")
    ]]></code></tearDown>
    <test>
      <task>combine with inclusion</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine3.xml"),
          map {})
      ]]></code>
      <xpath desc="has @jf:document on root element">matches(./tei:TEI/@jf:document,"^(/exist/restxq)?/api/data/tests/combine3$")</xpath>
      <xpath desc="has @jf:document on the included element">matches(./tei:TEI//jf:ptr[@jf:id="ptr1"]/@jf:document,"^(/exist/restxq)?/api/data/tests/combine1$")</xpath>
      <xpath 
        desc="incorporate destination in-place" 
        >exists(./tei:TEI/tei:text/jf:combined[@jf:id="stream"]/jf:ptr[@jf:id="ptr1"][ends-with(@jf:stream,"#stream")]/tei:seg[@jf:id="seg1"])
      </xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>combine:tei-fs-to-map()</testName>
    <test>
      <task>fs/f/symbol</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FSYMBOL">
              <tei:symbol value="SYMBOL"/>
            </tei:f>
          </tei:fs>,
          map {}
        )
        return $m("FS->FSYMBOL")
      ]]></code>
      <expected desc="map to symbol value"><tei:string>SYMBOL</tei:string></expected>
    </test>
    <test>
      <task>fs/f/binary</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FBINARY">
              <tei:binary value="1"/>
            </tei:f>
          </tei:fs>,
          map {}
        )
        return $m("FS->FBINARY")
      ]]></code>
      <expected desc="map to normalized binary value"><tei:string>true</tei:string></expected>
    </test>
    <test>
      <task>fs/f/yes</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FYES">
              <j:yes/>
            </tei:f>
          </tei:fs>,
          map {}
        )
        return $m("FS->FYES")
      ]]></code>
      <expected desc="map to yes value"><tei:string>YES</tei:string></expected>
    </test>
    <test>
      <task>fs/f/string</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FSTRING"><tei:string>string</tei:string></tei:f>
          </tei:fs>,
          map {}
        )
        return $m("FS->FSTRING")
      ]]></code>
      <expected desc="map to string value"><tei:string>string</tei:string></expected>
    </test>
    <test>
      <task>fs/f/text()</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FTEXT">text</tei:f>
          </tei:fs>,
          map {}
        )
        return $m("FS->FTEXT")
      ]]></code>
      <expected desc="map to text value"><tei:string>text</tei:string></expected>
    </test>
    <test>
      <task>fs/f/vColl</task>
      <code><![CDATA[
        let $m := combine:tei-fs-to-map(
          <tei:fs type="FS">
            <tei:f name="FVCOLL">
              <tei:vColl>
                <tei:symbol value="S1"/>
                <tei:symbol value="S2"/>
                <tei:symbol value="S3"/>
              </tei:vColl>
            </tei:f>
          </tei:fs>,
          map {}
        )
        return element x { $m("FS->FVCOLL") }
      ]]></code>
      <expected desc="map to sequence of strings">
        <x>
            <tei:string>S1</tei:string>
            <tei:string>S2</tei:string>
            <tei:string>S3</tei:string>
        </x>
      </expected>
    </test>
  </TestSet>
  <TestSet>
    <testName>combine:update-settings-from-standoff-markup()</testName>
    <setup>
      <code><![CDATA[
        local:setup("combine-settings.xml")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
        local:tearDown("combine-settings.xml")
      ]]></code>
    </tearDown>
    <test output="text">
      <task>update settings for segment with inbound link</task>
      <code><![CDATA[
        let $m :=
        combine:update-settings-from-standoff-markup(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-settings.xml")//tei:seg[@jf:id="seg1"],
          map {
            "combine:unmirrored-doc" := doc("/db/data/tests/combine-settings.xml"),
            "combine:setting-links" := doc("/db/data/tests/combine-settings.xml")//tei:link[@type="set"]
          },
          false()
        )
        return $m("combine:settings")("FS1->F1")
      ]]></code>
      <expected desc="setting is set">ONE</expected>
    </test>
    <test output="text">
      <task>update settings for segment with no inbound links</task>
      <code><![CDATA[
        let $m :=
        combine:update-settings-from-standoff-markup(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-settings.xml")//tei:seg[@jf:id="seg2"],
          map {
            "combine:unmirrored-doc" := doc("/db/data/tests/combine-settings.xml"),
            "combine:setting-links" := doc("/db/data/tests/combine-settings.xml")//tei:link[@type="set"]
          },
          false()
        )
        return count(map:keys($m("combine:settings")))
      ]]></code>
      <expected desc="settings are empty">0</expected>
    </test>
    <test>
      <task>update settings with ancestors for segment with inbound link</task>
      <code><![CDATA[
        let $m :=
        combine:update-settings-from-standoff-markup(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-settings.xml")//tei:seg[@jf:id="seg1"],
          map {
            "combine:unmirrored-doc" := doc("/db/data/tests/combine-settings.xml"),
            "combine:setting-links" := doc("/db/data/tests/combine-settings.xml")//tei:link[@type="set"]
          },
          true()
        )
        return 
          <values 
            f1="{$m('combine:settings')('FS1->F1')}" 
            f3="{$m('combine:settings')('FS1->F3')}" 
            f2="{$m('combine:settings')('FS1->F2')}"/>
      ]]></code>
      <xpath desc="non-overridden setting from ancestor is retained">./@f2="THREE"</xpath>
      <xpath desc="overridden setting from ancestor is overridden">./@f1="ONE"</xpath>
      <xpath desc="non-overridden setting from this is retained">./@f3="FOUR"</xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>Parallel texts</testName>
    <setup>
      <code><![CDATA[
      local:setup("parallel-simple-A.xml"),
      local:setup("parallel-simple-B.xml"),
      local:setup("include-simple-1.xml"),
      local:setup("linkage-simple.xml", "linkage")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("include-simple-1.xml"),
      local:tearDown("linkage-simple.xml", "linkage"),
      local:tearDown("parallel-simple-A.xml"),
      local:tearDown("parallel-simple-B.xml")
      ]]></code>
    </tearDown>
    <test>
      <task>Simple inclusion set inside the stream</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/include-simple-1.xml"),
          map {})
      ]]></code>
      <xpath desc="the inclusion pointer is followed through a redirect">.//jf:ptr[@jf:id="inc3"]/jf:combined[@type="parallel"]</xpath>
      <xpath desc="the correct domain is chosen">.//jf:ptr[@jf:id="inc3"]/jf:combined/@jf:domain="/data/tests/parallel-simple-A#stream"</xpath>
      <xpath desc="the redirect includes the original text">.//jf:ptr[@jf:id="inc3"]/jf:combined/jf:parallelGrp/jf:parallel[@domain="/data/tests/parallel-simple-A#stream"]/tei:seg[.="A-1"]</xpath>
      <xpath desc="the redirect includes the parallel text">.//jf:ptr[@jf:id="inc3"]/jf:combined/jf:parallelGrp/jf:parallel[@domain="/data/tests/parallel-simple-B#stream"]/jf:ptr/tei:seg[.="B-1"]</xpath>
      
    </test>
  </TestSet>
  <TestSet>
    <testName>Parallel texts: Set parallelism in the same document as it is used</testName>
    <setup>
      <code><![CDATA[
      local:setup("parallel-same-A.xml"),
      local:setup("parallel-simple-B.xml"),
      local:setup("linkage-same.xml", "linkage")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("linkage-same.xml", "linkage"),
      local:tearDown("parallel-same-A.xml"),
      local:tearDown("parallel-simple-B.xml")
      ]]></code>
    </tearDown>
    <test>
      <task>Simple parallelism</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/parallel-same-A.xml"),
          map {})
      ]]></code>
      <xpath desc="the stream is redirected">exists(.//tei:text/jf:combined[@jf:id="stream"]/jf:combined[@type="parallel"])</xpath>
      <xpath desc="the correct domain is chosen">.//jf:combined[@type="parallel"]/@jf:domain="/data/tests/parallel-same-A#stream"</xpath>
      <xpath desc="the redirect includes the original text">.//jf:combined[@type="parallel"]/jf:parallelGrp/jf:parallel[@domain="/data/tests/parallel-same-A#stream"]/tei:seg[.="A-1"]</xpath>
      <xpath desc="the redirect includes the parallel text">.//jf:combined[@type="parallel"]/jf:parallelGrp/jf:parallel[@domain="/data/tests/parallel-simple-B#stream"]/jf:ptr/tei:seg[.="B-1"]</xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>Parallel texts: Request a part of a parallel document</testName>
    <setup>
      <code><![CDATA[
      local:setup("parallel-part-A.xml"),
      local:setup("parallel-part-B.xml"),
      local:setup("include-part-1.xml"),
      local:setup("include-part-2.xml"),
      local:setup("linkage-part.xml", "linkage")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("linkage-part.xml", "linkage"),
      local:tearDown("parallel-part-A.xml"),
      local:tearDown("parallel-part-B.xml"),
      local:tearDown("include-part-1.xml"),
      local:tearDown("include-part-2.xml")
      ]]></code>
    </tearDown>
    <test>
      <task>Include where the boundaries are the same as the boundaries of the parallelism</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/include-part-1.xml"),
          map {})
      ]]></code>
      <xpath desc="the stream is redirected">exists(.//tei:text/jf:combined[@jf:id="stream"]/jf:ptr[@jf:id="inc1"]/jf:parallelGrp)</xpath>
      <xpath desc="the correct domain is chosen">exists(.//jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg)</xpath>
      <xpath desc="the redirect begins at the first requested part">.//jf:ptr[@jf:id="inc1"]/jf:parallelGrp[1]/jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg[1]/@jf:id="A2"</xpath>
      <xpath desc="the redirect ends at the last requested part">.//jf:ptr[@jf:id="inc1"]/jf:parallelGrp[last()]/jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg[last()]/@jf:id="A7"</xpath>
    </test>
    <test>
      <task>Include where the boundaries are different than the boundaries of the parallelism</task>
      <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/include-part-2.xml"),
          map {})
      ]]></code>
      <xpath desc="the stream is redirected">exists(.//tei:text/jf:combined[@jf:id="stream"]/jf:ptr[@jf:id="inc2"]/jf:parallelGrp)</xpath>
      <xpath desc="the correct domain is chosen">exists(.//jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg)</xpath>
      <xpath desc="the redirect begins at the first parallelGrp that includes the beginning of the first requested part">.//jf:ptr[@jf:id="inc2"]/jf:parallelGrp[1]/jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg[1]/@jf:id="A2"</xpath>
      <xpath desc="the redirect ends at the last parallelGrp that includes the end of the last requested part">.//jf:ptr[@jf:id="inc2"]/jf:parallelGrp[last()]/jf:parallel[@domain="/data/tests/parallel-part-A#stream"]/tei:seg[last()]/@jf:id="A7"</xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>Conditionals during combine that affect the streamText</testName>
    <setup>
      <code><![CDATA[
      local:setup("combine-cond1.xml")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("combine-cond1.xml")
      ]]></code>
    </tearDown>
    <test>
        <task>conditionals affecting inside a streamText</task>
        <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-cond1.xml"),
          map {})
        ]]></code>
        <xpath desc="seg1 exists and is directly enclosed in a jf:conditional">exists(.//*[@jf:id="seg1"]/parent::jf:conditional)</xpath>
        <xpath desc="seg2 does not exist at all">empty(.//*[@jf:id="seg2"])</xpath>
        <xpath desc="seg3 has an instruction added">exists(.//*[@jf:id="seg3"]/parent::jf:conditional[jf:annotation])</xpath>
    </test>
  </TestSet>
  <TestSet>
    <testName>Conditionals during combine that affect layers</testName>
    <setup>
      <code><![CDATA[
      local:setup("combine-cond2.xml")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("combine-cond2.xml")
      ]]></code>
    </tearDown>
    <test>
        <task>conditionals affecting a layer</task>
        <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-cond2.xml"),
          map {})
        ]]></code>
        <xpath desc="on condition has a @jf:conditional and exists">exists(.//*[@jf:id="div1"][@jf:conditional])</xpath>
        <xpath desc="off condition: layer element that is off is not present ">empty(.//*[@jf:id="div2"])</xpath>
        <xpath desc="off condition: layer-based child of element that is off is not present">empty(.//*[@jf:id="ab2"])</xpath>
        <xpath desc="off condition: layer element without xml:id is not present">empty(.//tei:head[.="Heading2"])</xpath>
        <xpath desc="off condition: other layers are unaffected">exists(.//*[@jf:id="ab_wrapper"])</xpath>
        <xpath desc="off condition: segments are present">exists(.//*[@jf:id="seg3"]) and exists(.//*[@jf:id="seg4"])</xpath>
    </test>
<!--
    <test>
        <task>no conditional affecting a layer followed by inclusion of a document that has a layer of the same name</task>
    </test>
-->
  </TestSet>
  <TestSet>
    <testName>Conditionals with j:option</testName>
    <setup>
      <code><![CDATA[
      local:setup("combine-cond3.xml")
      ]]></code>
    </setup>
    <tearDown>
      <code><![CDATA[
      local:tearDown("combine-cond3.xml")
      ]]></code>
    </tearDown>
    <test>
        <task>conditionals with j:option</task>
        <code><![CDATA[
        combine:combine-document(
          mirror:doc($format:unflatten-cache, "/db/data/tests/combine-cond3.xml"),
          map {})
        ]]></code>
        <xpath desc="no jf:conditional elements have been added">empty(.//jf:conditional)</xpath>
        <xpath desc="opt1 and seg1 exist">exists(.//j:option[@jf:id="opt1"][@jf:conditional]) and exists(.//tei:seg[@jf:id="seg1"])</xpath>
        <xpath desc="opt2 and seg2 removed">empty(.//j:option[@jf:id="opt2"]) and empty(.//tei:seg[@jf:id="seg2"])</xpath>
        <xpath desc="opt3 and seg3 exist, an instruction has been added">exists(.//j:option[@jf:id="opt3"][@jf:conditional][@jf:conditional-instruction][descendant::jf:annotation]) and exists(.//tei:seg[@jf:id="seg3"])</xpath>
        <xpath desc="opt4 exists">exists(.//j:option[@jf:id="opt4"][@jf:conditional][tei:w])</xpath>
        <xpath desc="opt5 removed">empty(.//j:option[@jf:id="opt5"]) and empty(.//tei:w[.="E"])</xpath>
        <xpath desc="opt6 exists, an instruction has been added">exists(.//j:option[@jf:id="opt6"][@jf:conditional][@jf:conditional-instruction][jf:annotation][tei:w])</xpath>
    </test>
<!--
    <test>
        <task>no conditional affecting a layer followed by inclusion of a document that has a layer of the same name</task>
    </test>
-->
  </TestSet>
</TestSuite>
